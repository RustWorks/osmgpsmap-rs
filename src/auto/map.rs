// This file was generated by gir (https://github.com/gtk-rs/gir @ f9ec115)
// from gir-files (https://github.com/gtk-rs/gir-files @ ???)
// DO NOT EDIT

use MapImage;
use MapKey_t;
use MapLayer;
use MapPoint;
use MapPolygon;
use MapSource_t;
use MapTrack;
use gdk;
use gdk_pixbuf;
use glib::GString;
use glib::StaticType;
use glib::Value;
use glib::object::Cast;
use glib::object::IsA;
use glib::signal::SignalHandlerId;
use glib::signal::connect_raw;
use glib::translate::*;
use glib_sys;
use gobject_sys;
use gtk;
use osm_gps_map_sys;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem;
use std::mem::transmute;

glib_wrapper! {
    pub struct Map(Object<osm_gps_map_sys::OsmGpsMap, osm_gps_map_sys::OsmGpsMapClass, MapClass>) @extends gtk::Widget;

    match fn {
        get_type => || osm_gps_map_sys::osm_gps_map_get_type(),
    }
}

impl Map {
    pub fn new() -> Map {
        assert_initialized_main_thread!();
        unsafe {
            gtk::Widget::from_glib_none(osm_gps_map_sys::osm_gps_map_new()).unsafe_cast()
        }
    }

    pub fn get_default_cache_directory() -> Option<GString> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(osm_gps_map_sys::osm_gps_map_get_default_cache_directory())
        }
    }

    pub fn source_get_copyright(source: MapSource_t) -> Option<GString> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(osm_gps_map_sys::osm_gps_map_source_get_copyright(source.to_glib()))
        }
    }

    pub fn source_get_friendly_name(source: MapSource_t) -> Option<GString> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(osm_gps_map_sys::osm_gps_map_source_get_friendly_name(source.to_glib()))
        }
    }

    pub fn source_get_image_format(source: MapSource_t) -> Option<GString> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(osm_gps_map_sys::osm_gps_map_source_get_image_format(source.to_glib()))
        }
    }

    pub fn source_get_max_zoom(source: MapSource_t) -> i32 {
        assert_initialized_main_thread!();
        unsafe {
            osm_gps_map_sys::osm_gps_map_source_get_max_zoom(source.to_glib())
        }
    }

    pub fn source_get_min_zoom(source: MapSource_t) -> i32 {
        assert_initialized_main_thread!();
        unsafe {
            osm_gps_map_sys::osm_gps_map_source_get_min_zoom(source.to_glib())
        }
    }

    pub fn source_get_repo_uri(source: MapSource_t) -> Option<GString> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(osm_gps_map_sys::osm_gps_map_source_get_repo_uri(source.to_glib()))
        }
    }

    pub fn source_is_valid(source: MapSource_t) -> bool {
        assert_initialized_main_thread!();
        unsafe {
            from_glib(osm_gps_map_sys::osm_gps_map_source_is_valid(source.to_glib()))
        }
    }
}

impl Default for Map {
    fn default() -> Self {
        Self::new()
    }
}

pub const NONE_MAP: Option<&Map> = None;

pub trait MapExt: 'static {
    fn convert_geographic_to_screen(&self, pt: &mut MapPoint) -> (i32, i32);

    fn convert_screen_to_geographic(&self, pixel_x: i32, pixel_y: i32) -> MapPoint;

    fn download_cancel_all(&self);

    fn download_maps(&self, pt1: &mut MapPoint, pt2: &mut MapPoint, zoom_start: i32, zoom_end: i32);

    fn get_bbox(&self) -> (MapPoint, MapPoint);

    fn get_event_location(&self, event: &mut gdk::EventButton) -> Option<MapPoint>;

    fn get_scale(&self) -> f32;

    fn gps_add(&self, latitude: f32, longitude: f32, heading: f32);

    fn gps_clear(&self);

    fn gps_get_track(&self) -> Option<MapTrack>;

    fn image_add(&self, latitude: f32, longitude: f32, image: &gdk_pixbuf::Pixbuf) -> Option<MapImage>;

    fn image_add_with_alignment(&self, latitude: f32, longitude: f32, image: &gdk_pixbuf::Pixbuf, xalign: f32, yalign: f32) -> Option<MapImage>;

    fn image_add_with_alignment_z(&self, latitude: f32, longitude: f32, image: &gdk_pixbuf::Pixbuf, xalign: f32, yalign: f32, zorder: i32) -> Option<MapImage>;

    fn image_add_z(&self, latitude: f32, longitude: f32, image: &gdk_pixbuf::Pixbuf, zorder: i32) -> Option<MapImage>;

    fn image_remove<P: IsA<MapImage>>(&self, image: &P) -> bool;

    fn image_remove_all(&self);

    fn layer_add<P: IsA<MapLayer>>(&self, layer: &P);

    fn layer_remove<P: IsA<MapLayer>>(&self, layer: &P) -> bool;

    fn layer_remove_all(&self);

    fn map_redraw(&self) -> bool;

    fn map_redraw_idle(&self);

    fn polygon_add<P: IsA<MapPolygon>>(&self, poly: &P);

    fn polygon_remove<P: IsA<MapPolygon>>(&self, poly: &P) -> bool;

    fn polygon_remove_all(&self);

    fn scroll(&self, dx: i32, dy: i32);

    fn set_center(&self, latitude: f32, longitude: f32);

    fn set_center_and_zoom(&self, latitude: f32, longitude: f32, zoom: i32);

    fn set_keyboard_shortcut(&self, key: MapKey_t, keyval: u32);

    fn set_zoom(&self, zoom: i32) -> i32;

    fn set_zoom_offset(&self, zoom_offset: i32);

    fn track_add<P: IsA<MapTrack>>(&self, track: &P);

    fn track_remove<P: IsA<MapTrack>>(&self, track: &P) -> bool;

    fn track_remove_all(&self);

    fn zoom_fit_bbox(&self, latitude1: f32, latitude2: f32, longitude1: f32, longitude2: f32);

    fn zoom_in(&self) -> i32;

    fn zoom_out(&self) -> i32;

    fn get_property_auto_center(&self) -> bool;

    fn set_property_auto_center(&self, auto_center: bool);

    fn get_property_auto_center_threshold(&self) -> f32;

    fn set_property_auto_center_threshold(&self, auto_center_threshold: f32);

    fn get_property_auto_download(&self) -> bool;

    fn set_property_auto_download(&self, auto_download: bool);

    fn get_property_drag_limit(&self) -> i32;

    fn get_property_gps_track_highlight_radius(&self) -> i32;

    fn set_property_gps_track_highlight_radius(&self, gps_track_highlight_radius: i32);

    fn get_property_gps_track_point_radius(&self) -> i32;

    fn set_property_gps_track_point_radius(&self, gps_track_point_radius: i32);

    fn get_property_gps_track_width(&self) -> f32;

    fn set_property_gps_track_width(&self, gps_track_width: f32);

    fn get_property_image_format(&self) -> Option<GString>;

    fn get_property_latitude(&self) -> f32;

    fn get_property_longitude(&self) -> f32;

    fn get_property_map_source(&self) -> i32;

    fn set_property_map_source(&self, map_source: i32);

    fn get_property_map_x(&self) -> i32;

    fn get_property_map_y(&self) -> i32;

    fn get_property_max_zoom(&self) -> i32;

    fn get_property_min_zoom(&self) -> i32;

    fn get_property_proxy_uri(&self) -> Option<GString>;

    fn get_property_record_trip_history(&self) -> bool;

    fn set_property_record_trip_history(&self, record_trip_history: bool);

    fn get_property_repo_uri(&self) -> Option<GString>;

    fn get_property_show_gps_point(&self) -> bool;

    fn set_property_show_gps_point(&self, show_gps_point: bool);

    fn get_property_show_trip_history(&self) -> bool;

    fn set_property_show_trip_history(&self, show_trip_history: bool);

    fn get_property_tile_cache(&self) -> Option<GString>;

    fn set_property_tile_cache(&self, tile_cache: Option<&str>);

    fn get_property_tile_cache_base(&self) -> Option<GString>;

    fn get_property_tile_zoom_offset(&self) -> i32;

    fn get_property_tiles_queued(&self) -> i32;

    fn get_property_user_agent(&self) -> Option<GString>;

    fn set_property_user_agent(&self, user_agent: Option<&str>);

    fn get_property_zoom(&self) -> i32;

    fn connect_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_auto_center_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_auto_center_threshold_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_auto_download_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_gps_track_highlight_radius_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_gps_track_point_radius_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_gps_track_width_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_latitude_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_longitude_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_map_source_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_record_trip_history_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_show_gps_point_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_show_trip_history_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_tile_cache_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_tiles_queued_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_user_agent_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Map>> MapExt for O {
    fn convert_geographic_to_screen(&self, pt: &mut MapPoint) -> (i32, i32) {
        unsafe {
            let mut pixel_x = mem::uninitialized();
            let mut pixel_y = mem::uninitialized();
            osm_gps_map_sys::osm_gps_map_convert_geographic_to_screen(self.as_ref().to_glib_none().0, pt.to_glib_none_mut().0, &mut pixel_x, &mut pixel_y);
            (pixel_x, pixel_y)
        }
    }

    fn convert_screen_to_geographic(&self, pixel_x: i32, pixel_y: i32) -> MapPoint {
        unsafe {
            let mut pt = MapPoint::uninitialized();
            osm_gps_map_sys::osm_gps_map_convert_screen_to_geographic(self.as_ref().to_glib_none().0, pixel_x, pixel_y, pt.to_glib_none_mut().0);
            pt
        }
    }

    fn download_cancel_all(&self) {
        unsafe {
            osm_gps_map_sys::osm_gps_map_download_cancel_all(self.as_ref().to_glib_none().0);
        }
    }

    fn download_maps(&self, pt1: &mut MapPoint, pt2: &mut MapPoint, zoom_start: i32, zoom_end: i32) {
        unsafe {
            osm_gps_map_sys::osm_gps_map_download_maps(self.as_ref().to_glib_none().0, pt1.to_glib_none_mut().0, pt2.to_glib_none_mut().0, zoom_start, zoom_end);
        }
    }

    fn get_bbox(&self) -> (MapPoint, MapPoint) {
        unsafe {
            let mut pt1 = MapPoint::uninitialized();
            let mut pt2 = MapPoint::uninitialized();
            osm_gps_map_sys::osm_gps_map_get_bbox(self.as_ref().to_glib_none().0, pt1.to_glib_none_mut().0, pt2.to_glib_none_mut().0);
            (pt1, pt2)
        }
    }

    fn get_event_location(&self, event: &mut gdk::EventButton) -> Option<MapPoint> {
        unsafe {
            from_glib_full(osm_gps_map_sys::osm_gps_map_get_event_location(self.as_ref().to_glib_none().0, event.to_glib_none_mut().0))
        }
    }

    fn get_scale(&self) -> f32 {
        unsafe {
            osm_gps_map_sys::osm_gps_map_get_scale(self.as_ref().to_glib_none().0)
        }
    }

    fn gps_add(&self, latitude: f32, longitude: f32, heading: f32) {
        unsafe {
            osm_gps_map_sys::osm_gps_map_gps_add(self.as_ref().to_glib_none().0, latitude, longitude, heading);
        }
    }

    fn gps_clear(&self) {
        unsafe {
            osm_gps_map_sys::osm_gps_map_gps_clear(self.as_ref().to_glib_none().0);
        }
    }

    fn gps_get_track(&self) -> Option<MapTrack> {
        unsafe {
            from_glib_none(osm_gps_map_sys::osm_gps_map_gps_get_track(self.as_ref().to_glib_none().0))
        }
    }

    fn image_add(&self, latitude: f32, longitude: f32, image: &gdk_pixbuf::Pixbuf) -> Option<MapImage> {
        unsafe {
            from_glib_full(osm_gps_map_sys::osm_gps_map_image_add(self.as_ref().to_glib_none().0, latitude, longitude, image.to_glib_none().0))
        }
    }

    fn image_add_with_alignment(&self, latitude: f32, longitude: f32, image: &gdk_pixbuf::Pixbuf, xalign: f32, yalign: f32) -> Option<MapImage> {
        unsafe {
            from_glib_full(osm_gps_map_sys::osm_gps_map_image_add_with_alignment(self.as_ref().to_glib_none().0, latitude, longitude, image.to_glib_none().0, xalign, yalign))
        }
    }

    fn image_add_with_alignment_z(&self, latitude: f32, longitude: f32, image: &gdk_pixbuf::Pixbuf, xalign: f32, yalign: f32, zorder: i32) -> Option<MapImage> {
        unsafe {
            from_glib_full(osm_gps_map_sys::osm_gps_map_image_add_with_alignment_z(self.as_ref().to_glib_none().0, latitude, longitude, image.to_glib_none().0, xalign, yalign, zorder))
        }
    }

    fn image_add_z(&self, latitude: f32, longitude: f32, image: &gdk_pixbuf::Pixbuf, zorder: i32) -> Option<MapImage> {
        unsafe {
            from_glib_full(osm_gps_map_sys::osm_gps_map_image_add_z(self.as_ref().to_glib_none().0, latitude, longitude, image.to_glib_none().0, zorder))
        }
    }

    fn image_remove<P: IsA<MapImage>>(&self, image: &P) -> bool {
        unsafe {
            from_glib(osm_gps_map_sys::osm_gps_map_image_remove(self.as_ref().to_glib_none().0, image.as_ref().to_glib_none().0))
        }
    }

    fn image_remove_all(&self) {
        unsafe {
            osm_gps_map_sys::osm_gps_map_image_remove_all(self.as_ref().to_glib_none().0);
        }
    }

    fn layer_add<P: IsA<MapLayer>>(&self, layer: &P) {
        unsafe {
            osm_gps_map_sys::osm_gps_map_layer_add(self.as_ref().to_glib_none().0, layer.as_ref().to_glib_none().0);
        }
    }

    fn layer_remove<P: IsA<MapLayer>>(&self, layer: &P) -> bool {
        unsafe {
            from_glib(osm_gps_map_sys::osm_gps_map_layer_remove(self.as_ref().to_glib_none().0, layer.as_ref().to_glib_none().0))
        }
    }

    fn layer_remove_all(&self) {
        unsafe {
            osm_gps_map_sys::osm_gps_map_layer_remove_all(self.as_ref().to_glib_none().0);
        }
    }

    fn map_redraw(&self) -> bool {
        unsafe {
            from_glib(osm_gps_map_sys::osm_gps_map_map_redraw(self.as_ref().to_glib_none().0))
        }
    }

    fn map_redraw_idle(&self) {
        unsafe {
            osm_gps_map_sys::osm_gps_map_map_redraw_idle(self.as_ref().to_glib_none().0);
        }
    }

    fn polygon_add<P: IsA<MapPolygon>>(&self, poly: &P) {
        unsafe {
            osm_gps_map_sys::osm_gps_map_polygon_add(self.as_ref().to_glib_none().0, poly.as_ref().to_glib_none().0);
        }
    }

    fn polygon_remove<P: IsA<MapPolygon>>(&self, poly: &P) -> bool {
        unsafe {
            from_glib(osm_gps_map_sys::osm_gps_map_polygon_remove(self.as_ref().to_glib_none().0, poly.as_ref().to_glib_none().0))
        }
    }

    fn polygon_remove_all(&self) {
        unsafe {
            osm_gps_map_sys::osm_gps_map_polygon_remove_all(self.as_ref().to_glib_none().0);
        }
    }

    fn scroll(&self, dx: i32, dy: i32) {
        unsafe {
            osm_gps_map_sys::osm_gps_map_scroll(self.as_ref().to_glib_none().0, dx, dy);
        }
    }

    fn set_center(&self, latitude: f32, longitude: f32) {
        unsafe {
            osm_gps_map_sys::osm_gps_map_set_center(self.as_ref().to_glib_none().0, latitude, longitude);
        }
    }

    fn set_center_and_zoom(&self, latitude: f32, longitude: f32, zoom: i32) {
        unsafe {
            osm_gps_map_sys::osm_gps_map_set_center_and_zoom(self.as_ref().to_glib_none().0, latitude, longitude, zoom);
        }
    }

    fn set_keyboard_shortcut(&self, key: MapKey_t, keyval: u32) {
        unsafe {
            osm_gps_map_sys::osm_gps_map_set_keyboard_shortcut(self.as_ref().to_glib_none().0, key.to_glib(), keyval);
        }
    }

    fn set_zoom(&self, zoom: i32) -> i32 {
        unsafe {
            osm_gps_map_sys::osm_gps_map_set_zoom(self.as_ref().to_glib_none().0, zoom)
        }
    }

    fn set_zoom_offset(&self, zoom_offset: i32) {
        unsafe {
            osm_gps_map_sys::osm_gps_map_set_zoom_offset(self.as_ref().to_glib_none().0, zoom_offset);
        }
    }

    fn track_add<P: IsA<MapTrack>>(&self, track: &P) {
        unsafe {
            osm_gps_map_sys::osm_gps_map_track_add(self.as_ref().to_glib_none().0, track.as_ref().to_glib_none().0);
        }
    }

    fn track_remove<P: IsA<MapTrack>>(&self, track: &P) -> bool {
        unsafe {
            from_glib(osm_gps_map_sys::osm_gps_map_track_remove(self.as_ref().to_glib_none().0, track.as_ref().to_glib_none().0))
        }
    }

    fn track_remove_all(&self) {
        unsafe {
            osm_gps_map_sys::osm_gps_map_track_remove_all(self.as_ref().to_glib_none().0);
        }
    }

    fn zoom_fit_bbox(&self, latitude1: f32, latitude2: f32, longitude1: f32, longitude2: f32) {
        unsafe {
            osm_gps_map_sys::osm_gps_map_zoom_fit_bbox(self.as_ref().to_glib_none().0, latitude1, latitude2, longitude1, longitude2);
        }
    }

    fn zoom_in(&self) -> i32 {
        unsafe {
            osm_gps_map_sys::osm_gps_map_zoom_in(self.as_ref().to_glib_none().0)
        }
    }

    fn zoom_out(&self) -> i32 {
        unsafe {
            osm_gps_map_sys::osm_gps_map_zoom_out(self.as_ref().to_glib_none().0)
        }
    }

    fn get_property_auto_center(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"auto-center\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn set_property_auto_center(&self, auto_center: bool) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"auto-center\0".as_ptr() as *const _, Value::from(&auto_center).to_glib_none().0);
        }
    }

    fn get_property_auto_center_threshold(&self) -> f32 {
        unsafe {
            let mut value = Value::from_type(<f32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"auto-center-threshold\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn set_property_auto_center_threshold(&self, auto_center_threshold: f32) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"auto-center-threshold\0".as_ptr() as *const _, Value::from(&auto_center_threshold).to_glib_none().0);
        }
    }

    fn get_property_auto_download(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"auto-download\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn set_property_auto_download(&self, auto_download: bool) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"auto-download\0".as_ptr() as *const _, Value::from(&auto_download).to_glib_none().0);
        }
    }

    fn get_property_drag_limit(&self) -> i32 {
        unsafe {
            let mut value = Value::from_type(<i32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"drag-limit\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn get_property_gps_track_highlight_radius(&self) -> i32 {
        unsafe {
            let mut value = Value::from_type(<i32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"gps-track-highlight-radius\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn set_property_gps_track_highlight_radius(&self, gps_track_highlight_radius: i32) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"gps-track-highlight-radius\0".as_ptr() as *const _, Value::from(&gps_track_highlight_radius).to_glib_none().0);
        }
    }

    fn get_property_gps_track_point_radius(&self) -> i32 {
        unsafe {
            let mut value = Value::from_type(<i32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"gps-track-point-radius\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn set_property_gps_track_point_radius(&self, gps_track_point_radius: i32) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"gps-track-point-radius\0".as_ptr() as *const _, Value::from(&gps_track_point_radius).to_glib_none().0);
        }
    }

    fn get_property_gps_track_width(&self) -> f32 {
        unsafe {
            let mut value = Value::from_type(<f32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"gps-track-width\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn set_property_gps_track_width(&self, gps_track_width: f32) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"gps-track-width\0".as_ptr() as *const _, Value::from(&gps_track_width).to_glib_none().0);
        }
    }

    fn get_property_image_format(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"image-format\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get()
        }
    }

    fn get_property_latitude(&self) -> f32 {
        unsafe {
            let mut value = Value::from_type(<f32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"latitude\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn get_property_longitude(&self) -> f32 {
        unsafe {
            let mut value = Value::from_type(<f32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"longitude\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn get_property_map_source(&self) -> i32 {
        unsafe {
            let mut value = Value::from_type(<i32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"map-source\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn set_property_map_source(&self, map_source: i32) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"map-source\0".as_ptr() as *const _, Value::from(&map_source).to_glib_none().0);
        }
    }

    fn get_property_map_x(&self) -> i32 {
        unsafe {
            let mut value = Value::from_type(<i32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"map-x\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn get_property_map_y(&self) -> i32 {
        unsafe {
            let mut value = Value::from_type(<i32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"map-y\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn get_property_max_zoom(&self) -> i32 {
        unsafe {
            let mut value = Value::from_type(<i32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"max-zoom\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn get_property_min_zoom(&self) -> i32 {
        unsafe {
            let mut value = Value::from_type(<i32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"min-zoom\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn get_property_proxy_uri(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"proxy-uri\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get()
        }
    }

    fn get_property_record_trip_history(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"record-trip-history\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn set_property_record_trip_history(&self, record_trip_history: bool) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"record-trip-history\0".as_ptr() as *const _, Value::from(&record_trip_history).to_glib_none().0);
        }
    }

    fn get_property_repo_uri(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"repo-uri\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get()
        }
    }

    fn get_property_show_gps_point(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"show-gps-point\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn set_property_show_gps_point(&self, show_gps_point: bool) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"show-gps-point\0".as_ptr() as *const _, Value::from(&show_gps_point).to_glib_none().0);
        }
    }

    fn get_property_show_trip_history(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"show-trip-history\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn set_property_show_trip_history(&self, show_trip_history: bool) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"show-trip-history\0".as_ptr() as *const _, Value::from(&show_trip_history).to_glib_none().0);
        }
    }

    fn get_property_tile_cache(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"tile-cache\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get()
        }
    }

    fn set_property_tile_cache(&self, tile_cache: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"tile-cache\0".as_ptr() as *const _, Value::from(tile_cache).to_glib_none().0);
        }
    }

    fn get_property_tile_cache_base(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"tile-cache-base\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get()
        }
    }

    fn get_property_tile_zoom_offset(&self) -> i32 {
        unsafe {
            let mut value = Value::from_type(<i32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"tile-zoom-offset\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn get_property_tiles_queued(&self) -> i32 {
        unsafe {
            let mut value = Value::from_type(<i32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"tiles-queued\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn get_property_user_agent(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"user-agent\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get()
        }
    }

    fn set_property_user_agent(&self, user_agent: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"user-agent\0".as_ptr() as *const _, Value::from(user_agent).to_glib_none().0);
        }
    }

    fn get_property_zoom(&self) -> i32 {
        unsafe {
            let mut value = Value::from_type(<i32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"zoom\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().unwrap()
        }
    }

    fn connect_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn changed_trampoline<P, F: Fn(&P) + 'static>(this: *mut osm_gps_map_sys::OsmGpsMap, f: glib_sys::gpointer)
            where P: IsA<Map>
        {
            let f: &F = &*(f as *const F);
            f(&Map::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"changed\0".as_ptr() as *const _,
                Some(transmute(changed_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_auto_center_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_auto_center_trampoline<P, F: Fn(&P) + 'static>(this: *mut osm_gps_map_sys::OsmGpsMap, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Map>
        {
            let f: &F = &*(f as *const F);
            f(&Map::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::auto-center\0".as_ptr() as *const _,
                Some(transmute(notify_auto_center_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_auto_center_threshold_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_auto_center_threshold_trampoline<P, F: Fn(&P) + 'static>(this: *mut osm_gps_map_sys::OsmGpsMap, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Map>
        {
            let f: &F = &*(f as *const F);
            f(&Map::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::auto-center-threshold\0".as_ptr() as *const _,
                Some(transmute(notify_auto_center_threshold_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_auto_download_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_auto_download_trampoline<P, F: Fn(&P) + 'static>(this: *mut osm_gps_map_sys::OsmGpsMap, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Map>
        {
            let f: &F = &*(f as *const F);
            f(&Map::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::auto-download\0".as_ptr() as *const _,
                Some(transmute(notify_auto_download_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_gps_track_highlight_radius_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_gps_track_highlight_radius_trampoline<P, F: Fn(&P) + 'static>(this: *mut osm_gps_map_sys::OsmGpsMap, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Map>
        {
            let f: &F = &*(f as *const F);
            f(&Map::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::gps-track-highlight-radius\0".as_ptr() as *const _,
                Some(transmute(notify_gps_track_highlight_radius_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_gps_track_point_radius_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_gps_track_point_radius_trampoline<P, F: Fn(&P) + 'static>(this: *mut osm_gps_map_sys::OsmGpsMap, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Map>
        {
            let f: &F = &*(f as *const F);
            f(&Map::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::gps-track-point-radius\0".as_ptr() as *const _,
                Some(transmute(notify_gps_track_point_radius_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_gps_track_width_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_gps_track_width_trampoline<P, F: Fn(&P) + 'static>(this: *mut osm_gps_map_sys::OsmGpsMap, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Map>
        {
            let f: &F = &*(f as *const F);
            f(&Map::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::gps-track-width\0".as_ptr() as *const _,
                Some(transmute(notify_gps_track_width_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_latitude_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_latitude_trampoline<P, F: Fn(&P) + 'static>(this: *mut osm_gps_map_sys::OsmGpsMap, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Map>
        {
            let f: &F = &*(f as *const F);
            f(&Map::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::latitude\0".as_ptr() as *const _,
                Some(transmute(notify_latitude_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_longitude_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_longitude_trampoline<P, F: Fn(&P) + 'static>(this: *mut osm_gps_map_sys::OsmGpsMap, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Map>
        {
            let f: &F = &*(f as *const F);
            f(&Map::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::longitude\0".as_ptr() as *const _,
                Some(transmute(notify_longitude_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_map_source_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_map_source_trampoline<P, F: Fn(&P) + 'static>(this: *mut osm_gps_map_sys::OsmGpsMap, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Map>
        {
            let f: &F = &*(f as *const F);
            f(&Map::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::map-source\0".as_ptr() as *const _,
                Some(transmute(notify_map_source_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_record_trip_history_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_record_trip_history_trampoline<P, F: Fn(&P) + 'static>(this: *mut osm_gps_map_sys::OsmGpsMap, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Map>
        {
            let f: &F = &*(f as *const F);
            f(&Map::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::record-trip-history\0".as_ptr() as *const _,
                Some(transmute(notify_record_trip_history_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_show_gps_point_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_show_gps_point_trampoline<P, F: Fn(&P) + 'static>(this: *mut osm_gps_map_sys::OsmGpsMap, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Map>
        {
            let f: &F = &*(f as *const F);
            f(&Map::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::show-gps-point\0".as_ptr() as *const _,
                Some(transmute(notify_show_gps_point_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_show_trip_history_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_show_trip_history_trampoline<P, F: Fn(&P) + 'static>(this: *mut osm_gps_map_sys::OsmGpsMap, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Map>
        {
            let f: &F = &*(f as *const F);
            f(&Map::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::show-trip-history\0".as_ptr() as *const _,
                Some(transmute(notify_show_trip_history_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_tile_cache_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_tile_cache_trampoline<P, F: Fn(&P) + 'static>(this: *mut osm_gps_map_sys::OsmGpsMap, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Map>
        {
            let f: &F = &*(f as *const F);
            f(&Map::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::tile-cache\0".as_ptr() as *const _,
                Some(transmute(notify_tile_cache_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_tiles_queued_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_tiles_queued_trampoline<P, F: Fn(&P) + 'static>(this: *mut osm_gps_map_sys::OsmGpsMap, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Map>
        {
            let f: &F = &*(f as *const F);
            f(&Map::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::tiles-queued\0".as_ptr() as *const _,
                Some(transmute(notify_tiles_queued_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_user_agent_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_user_agent_trampoline<P, F: Fn(&P) + 'static>(this: *mut osm_gps_map_sys::OsmGpsMap, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Map>
        {
            let f: &F = &*(f as *const F);
            f(&Map::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::user-agent\0".as_ptr() as *const _,
                Some(transmute(notify_user_agent_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }
}

impl fmt::Display for Map {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Map")
    }
}
